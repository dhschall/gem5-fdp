./pred/associative_btb.cc:38:#include "cpu/pred/associative_btb.hh"
./pred/associative_btb.cc:53:        btb(p.assoc, p.numEntries, p.indexing_policy,
./pred/associative_btb.cc:85:    for (auto &entry : btb) {
./pred/associative_btb.cc:128:    BTBEntry * entry = btb.findEntry(idx, /* unused */ false);
./pred/associative_btb.cc:149:    BTBEntry * entry = btb.findEntry(idx, /* unused */ false);
./pred/associative_btb.cc:158:        btb.accessEntry(entry);
./pred/associative_btb.cc:172:    BTBEntry * entry = btb.findEntry(idx, /* unused */ false);
./pred/associative_btb.cc:186:    BTBEntry * entry = btb.findEntry(idx, /* unused */ false);
./pred/associative_btb.cc:205:        btb.accessEntry(entry);
./pred/associative_btb.cc:215:        entry = btb.findVictim(idx);
./pred/associative_btb.cc:217:        btb.insertEntry(idx, false, entry);
./pred/SConscript:85:Source('btb.cc')
./pred/SConscript:86:Source('simple_btb.cc')
./pred/SConscript:87:Source('associative_btb.cc')
./pred/associative_btb.hh:43:#include "cpu/pred/btb.hh"
./pred/associative_btb.hh:106:    AssociativeSet<BTBEntry> btb;
./pred/simple_btb.cc:41:#include "cpu/pred/simple_btb.hh"
./pred/simple_btb.cc:66:    btb.resize(numEntries);
./pred/simple_btb.cc:69:        btb[i].valid = false;
./pred/simple_btb.cc:83:        btb[i].valid = false;
./pred/simple_btb.cc:107:    unsigned btb_idx = getIndex(instPC, tid);
./pred/simple_btb.cc:111:    assert(btb_idx < numEntries);
./pred/simple_btb.cc:113:    if (btb[btb_idx].valid
./pred/simple_btb.cc:114:        && inst_tag == btb[btb_idx].tag
./pred/simple_btb.cc:115:        && btb[btb_idx].tid == tid) {
./pred/simple_btb.cc:128:    unsigned btb_idx = getIndex(instPC, tid);
./pred/simple_btb.cc:131:    assert(btb_idx < numEntries);
./pred/simple_btb.cc:138:    if (btb[btb_idx].valid
./pred/simple_btb.cc:139:        && inst_tag == btb[btb_idx].tag
./pred/simple_btb.cc:140:        && btb[btb_idx].tid == tid) {
./pred/simple_btb.cc:141:        return btb[btb_idx].target.get();
./pred/simple_btb.cc:156:    unsigned btb_idx = getIndex(instPC, tid);
./pred/simple_btb.cc:158:    assert(btb_idx < numEntries);
./pred/simple_btb.cc:164:    btb[btb_idx].tid = tid;
./pred/simple_btb.cc:165:    btb[btb_idx].valid = true;
./pred/simple_btb.cc:166:    set(btb[btb_idx].target, target);
./pred/simple_btb.cc:167:    btb[btb_idx].tag = getTag(instPC);
./pred/bpred_unit.cc:67:      btb(params.BTB),
./pred/bpred_unit.cc:224:    const PCStateBase * btb_target = btb->lookup(tid, pc.instAddr(), brType);
./pred/bpred_unit.cc:225:    if (btb_target) {
./pred/bpred_unit.cc:227:        hist->btbHit = true;
./pred/bpred_unit.cc:231:            set(hist->target, btb_target);
./pred/bpred_unit.cc:236:            tid, seqNum, hist->pc,  (hist->btbHit) ? "hit" : "miss");
./pred/bpred_unit.cc:241:    const bool allow_btb_override =
./pred/bpred_unit.cc:242:                    (hist->btbHit || !requiresBTBHit) ? true : false;
./pred/bpred_unit.cc:254:    if (ras && allow_btb_override) {
./pred/bpred_unit.cc:301:        if (hist->predTaken && allow_btb_override &&
./pred/bpred_unit.cc:431:                              (onlyTaken_BTB && btb->valid(tid, hist->pc));
./pred/bpred_unit.cc:477:        btb->update(tid, hist->pc,
./pred/bpred_unit.cc:482:        if(!hist->btbHit){
./pred/bpred_unit.cc:484:	    btb->incorrectTarget(hist->pc, hist->type);
./pred/bpred_unit.cc:685:        if (actually_taken &&!hist->btbHit) {
./pred/bpred_unit.cc:690:            //btb->incorrectTarget(hist->pc, hist->type);
./pred/BranchPredictor.py:89:    cxx_header = "cpu/pred/btb.hh"
./pred/BranchPredictor.py:98:    cxx_header = "cpu/pred/simple_btb.hh"
./pred/BranchPredictor.py:110:    cxx_header = "cpu/pred/associative_btb.hh"
./pred/bpred_unit.hh:52:#include "cpu/pred/btb.hh"
./pred/bpred_unit.hh:250:        return btb->valid(tid, instPC);
./pred/bpred_unit.hh:267:        return btb->lookup(tid, instPC.instAddr());
./pred/bpred_unit.hh:283:        return btb->lookupInst(tid, instPC);
./pred/bpred_unit.hh:300:        return btb->update(tid, instPC, target);
./pred/bpred_unit.hh:319:              btbHit(false), targetProvider(TargetProvider::NoTarget),
./pred/bpred_unit.hh:333:              btbHit(false), targetProvider(TargetProvider::NoTarget),
./pred/bpred_unit.hh:386:        bool btbHit;
./pred/bpred_unit.hh:470:    BranchTargetBuffer * btb;
./pred/simple_btb.hh:46:#include "cpu/pred/btb.hh"
./pred/simple_btb.hh:100:    std::vector<BTBEntry> btb;
./pred/btb.cc:41:#include "cpu/pred/btb.hh"
